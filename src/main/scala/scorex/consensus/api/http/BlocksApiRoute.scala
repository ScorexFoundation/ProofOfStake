package scorex.consensus.api.http

import javax.ws.rs.Path

import akka.actor.ActorRefFactory
import akka.http.scaladsl.server.Route
import io.circe.generic.auto._
import io.circe.syntax._
import io.swagger.annotations._
import scorex.api.http.{ApiError, ApiRoute}
import scorex.app.Application
import scorex.block.{Block, ConsensusData}
import scorex.consensus.BlockChain
import scorex.crypto.encode.Base58
import scorex.transaction.box.PublicKey25519Proposition

@Path("/blocks")
@Api(value = "/blocks", description = "Info about blockchain & individual blocks within it")
case class BlocksApiRoute[CData <: ConsensusData, B <: Block[PublicKey25519Proposition, CData, _]](consensusModule: BlockChain[PublicKey25519Proposition, CData, B], application: Application)(implicit val context: ActorRefFactory)
  extends ApiRoute {

  private type P = PublicKey25519Proposition
  private type BT = application.BType
  private type CData = application.CData

  //private val consensusModule = application.consensusModule.asInstanceOf[BlockChain[PublicKey25519Proposition, CData, BT]] //todo: aIO

  override lazy val route =
    pathPrefix("blocks") {
      signature ~ first ~ last ~ at ~ seq ~ height ~ heightEncoded ~ child ~ address ~ delay
    }

  @Path("/address/{address}")
  @ApiOperation(value = "Address", notes = "Get list of blocks generated by specified address", httpMethod = "GET")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(name = "address", value = "Wallet address ", required = true, dataType = "String", paramType = "path")
  ))
  def address: Route = {
    path("address" / Segment) { case address =>
      getJsonRoute {
        PublicKey25519Proposition.validPubKey(address).map { pk =>
          consensusModule.generatedBy(pk).map(_.json).asJson //todo: asIO
        }.getOrElse(ApiError.invalidAddress)
      }
    }
  }

  @Path("/child/{signature}")
  @ApiOperation(value = "Child", notes = "Get children of specified block", httpMethod = "GET")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(name = "signature", value = "Base58-encoded signature", required = true, dataType = "String", paramType = "path")
  ))
  def child: Route = {
    path("child" / Segment) { case encodedId =>
      getJsonRoute {
        consensusModule
          .children(Base58.decode(encodedId).get) //todo: get
          .headOption
          .map(_.json)
          .getOrElse(Map("status" -> "error", "details" -> "No child blocks").asJson)
      }
    }
  }

  @Path("/delay/{signature}/{blockNum}")
  @ApiOperation(value = "Average delay", notes = "Average delay in milliseconds between last $blockNum blocks starting from $height", httpMethod = "GET")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(name = "signature", value = "Base58-encoded signature", required = true, dataType = "String", paramType = "path"),
    new ApiImplicitParam(name = "blockNum", value = "Number of blocks to count delay", required = true, dataType = "String", paramType = "path")
  ))
  def delay: Route = {
    path("delay" / Segment / IntNumber) { case (encodedId: String, count) =>
      getJsonRoute {
        withBlock(consensusModule, encodedId: String) { block =>
          consensusModule.averageDelay(block, count).map(d => ("delay" -> d).asJson)
            .getOrElse(Map("status" -> "error", "details" -> "Internal error").asJson)
        }
      }
    }
  }

  @Path("/height/{signature}")
  @ApiOperation(value = "Height", notes = "Get height of a block by its Base58-encoded signature", httpMethod = "GET")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(name = "signature", value = "Base58-encoded signature", required = true, dataType = "String", paramType = "path")
  ))
  def heightEncoded: Route = {
    path("height" / Segment) { case encodedId =>
      getJsonRoute {
        withBlock(consensusModule, encodedId) { block =>
          ("height" -> consensusModule.heightOf(block)).asJson
        }
      }
    }
  }

  @Path("/height")
  @ApiOperation(value = "Height", notes = "Get blockchain height", httpMethod = "GET")
  def height: Route = {
    path("height") {
      getJsonRoute {
        ("height" -> consensusModule.height()).asJson
      }
    }
  }

  @Path("/at/{height}")
  @ApiOperation(value = "At", notes = "Get block at specified height", httpMethod = "GET")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(name = "height", value = "Block height", required = true, dataType = "Long", paramType = "path")
  ))
  def at: Route = {
    path("at" / IntNumber) { case height =>
      getJsonRoute {
        consensusModule
          .blockAt(height)
          .map(_.json)
          .getOrElse(Map("status" -> "error", "details" -> "No block for this height").asJson)
      }
    }
  }

  @Path("/seq/{from}/{to}")
  @ApiOperation(value = "Seq", notes = "Get block at specified heights", httpMethod = "GET")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(name = "from", value = "Start block height", required = true, dataType = "Int", paramType = "path"),
    new ApiImplicitParam(name = "to", value = "End block height", required = true, dataType = "Int", paramType = "path")
  ))
  def seq: Route = {
    path("seq" / IntNumber / IntNumber) { case (start, end) =>
      getJsonRoute {
        (start to end).map { height =>
          consensusModule
            .blockAt(height)
            .map(_.json)
            .getOrElse(("error" -> s"No block at height $height").asJson)
        }.asJson
      }
    }
  }


  @Path("/last")
  @ApiOperation(value = "Last", notes = "Get last block data", httpMethod = "GET")
  def last: Route = {
    path("last") {
      getJsonRoute {
        consensusModule.lastBlock.json
      }
    }
  }

  @Path("/first")
  @ApiOperation(value = "First", notes = "Get genesis block data", httpMethod = "GET")
  def first: Route = {
    path("first") {
      getJsonRoute {
        consensusModule.genesisBlock.json
      }
    }
  }

  @Path("/signature/{signature}")
  @ApiOperation(value = "Signature", notes = "Get block by a specified Base58-encoded signature", httpMethod = "GET")
  @ApiImplicitParams(Array(
    new ApiImplicitParam(name = "signature", value = "Base58-encoded signature", required = true, dataType = "String", paramType = "path")
  ))
  def signature: Route = {
    path("signature" / Segment) { case encodedId =>
      getJsonRoute {
        withBlock(consensusModule, encodedId)(_.json)
      }
    }
  }
}